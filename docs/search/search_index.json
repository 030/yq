{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yq \u00b6 yq is a lightweight and portable command-line YAML processor The aim of the project is to be the jq or sed of yaml files. Install \u00b6 On MacOS: brew install yq On Ubuntu and other Linux distros supporting snap packages: snap install yq On Ubuntu 16.04 or higher from Debian package: sudo add-apt-repository ppa:rmescandon/yq sudo apt update sudo apt install yq -y or, Download latest binary or alternatively: GO111MODULE=on go get github.com/mikefarah/yq/v3 View on GitHub","title":"Install"},{"location":"#yq","text":"yq is a lightweight and portable command-line YAML processor The aim of the project is to be the jq or sed of yaml files.","title":"yq"},{"location":"#install","text":"On MacOS: brew install yq On Ubuntu and other Linux distros supporting snap packages: snap install yq On Ubuntu 16.04 or higher from Debian package: sudo add-apt-repository ppa:rmescandon/yq sudo apt update sudo apt install yq -y or, Download latest binary or alternatively: GO111MODULE=on go get github.com/mikefarah/yq/v3 View on GitHub","title":"Install"},{"location":"convert/","text":"Yaml to Json \u00b6 To convert output to json, use the --tojson (or -j) flag. This is supported by all commands. Each matching yaml node will be converted to json and printed out on a separate line. Given a sample.yaml file of: b: c: 2 then yq r -j sample.yaml will output {\"b\":{\"c\":2}} Given a sample.yaml file of: bob: c: 2 bab: c: 5 then yq r -j sample.yaml b* will output {\"c\":2} {\"c\":5} Json to Yaml \u00b6 To read in json, just pass in a json file instead of yaml, it will just work :) e.g given a json file {\"a\":\"Easy! as one two three\",\"b\":{\"c\":2,\"d\":[3,4]}} then yq r sample.json will output a: Easy! as one two three b: c: 2 d: - 3 - 4","title":"Convert"},{"location":"convert/#yaml-to-json","text":"To convert output to json, use the --tojson (or -j) flag. This is supported by all commands. Each matching yaml node will be converted to json and printed out on a separate line. Given a sample.yaml file of: b: c: 2 then yq r -j sample.yaml will output {\"b\":{\"c\":2}} Given a sample.yaml file of: bob: c: 2 bab: c: 5 then yq r -j sample.yaml b* will output {\"c\":2} {\"c\":5}","title":"Yaml to Json"},{"location":"convert/#json-to-yaml","text":"To read in json, just pass in a json file instead of yaml, it will just work :) e.g given a json file {\"a\":\"Easy! as one two three\",\"b\":{\"c\":2,\"d\":[3,4]}} then yq r sample.json will output a: Easy! as one two three b: c: 2 d: - 3 - 4","title":"Json to Yaml"},{"location":"create/","text":"yq n <path_expression> <new value> Yaml files can be created using the 'new' command. This works in the same way as the write command, but you don't pass in an existing Yaml file. Currently this does not support creating multiple documents in a single yaml file. See docs for path expression Creating a simple yaml file \u00b6 yq n b.c cat will output: b: c: cat Creating using a create script \u00b6 Create scripts follow the same format as the update scripts. Given a script create_instructions.yaml of: - command: update path: b.c value: #great things: frog # wow! then yq n -s create_instructions.yaml will output: b: c: #great things: frog # wow! You can also pipe the instructions in: cat create_instructions.yaml | yq n -s -","title":"Create"},{"location":"create/#creating-a-simple-yaml-file","text":"yq n b.c cat will output: b: c: cat","title":"Creating a simple yaml file"},{"location":"create/#creating-using-a-create-script","text":"Create scripts follow the same format as the update scripts. Given a script create_instructions.yaml of: - command: update path: b.c value: #great things: frog # wow! then yq n -s create_instructions.yaml will output: b: c: #great things: frog # wow! You can also pipe the instructions in: cat create_instructions.yaml | yq n -s -","title":"Creating using a create script"},{"location":"delete/","text":"yq delete <yaml_file|-> <path_expression> The delete command will delete all the matching nodes for the path expression in the given yaml input. See docs for path expression for more details. Deleting from a simple document \u00b6 Given a sample.yaml file of: b: c: 2 apples: green then yq d sample.yaml b.c will output b: apples: green From STDIN \u00b6 Use \"-\" (without quotes) in-place of a file name if you wish to pipe in input from STDIN. cat sample.yaml | yq d - b.c Deleting in-place \u00b6 yq d -i sample.yaml b.c will update the sample.yaml file so that the 'c' node is deleted Multiple Documents \u00b6 Delete from single document \u00b6 Given a sample.yaml file of: something: else field: leaveMe --- b: c: 2 field: deleteMe then yq w -d1 sample.yaml field will output: something: else field: leaveMe --- b: c: 2 Delete from all documents \u00b6 Given a sample.yaml file of: something: else field: deleteMe --- b: c: 2 field: deleteMeToo then yq w -d'*' sample.yaml field will output: something: else --- b: c: 2","title":"Delete"},{"location":"delete/#deleting-from-a-simple-document","text":"Given a sample.yaml file of: b: c: 2 apples: green then yq d sample.yaml b.c will output b: apples: green","title":"Deleting from a simple document"},{"location":"delete/#from-stdin","text":"Use \"-\" (without quotes) in-place of a file name if you wish to pipe in input from STDIN. cat sample.yaml | yq d - b.c","title":"From STDIN"},{"location":"delete/#deleting-in-place","text":"yq d -i sample.yaml b.c will update the sample.yaml file so that the 'c' node is deleted","title":"Deleting in-place"},{"location":"delete/#multiple-documents","text":"","title":"Multiple Documents"},{"location":"delete/#delete-from-single-document","text":"Given a sample.yaml file of: something: else field: leaveMe --- b: c: 2 field: deleteMe then yq w -d1 sample.yaml field will output: something: else field: leaveMe --- b: c: 2","title":"Delete from single document"},{"location":"delete/#delete-from-all-documents","text":"Given a sample.yaml file of: something: else field: deleteMe --- b: c: 2 field: deleteMeToo then yq w -d'*' sample.yaml field will output: something: else --- b: c: 2","title":"Delete from all documents"},{"location":"merge/","text":"Yaml files can be merged using the 'merge' command. Each additional file merged with the first file will set values for any key not existing already or where the key has no value. yq m <yaml_file> <path>... Merge example \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m data1.yaml data2.yaml will output: a: simple b: [1, 2] c: test: 1 Updating files in-place \u00b6 yq m -i data1.yaml data2.yaml will update the data1.yaml file with the merged result. Overwrite values \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -x data1.yaml data2.yaml will output: a: other b: [1, 2] c: test: 1 Overwrite values with arrays \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data3.yaml file of: b: [3, 4] c: test: 2 other: true d: false then yq m -x data1.yaml data3.yaml will output: a: simple b: [3, 4] c: test: 2 other: true d: false Notice that 'b' does not result in the merging of the values within an array. Append values with arrays \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] d: hi and data3.yaml file of: a: something b: [3, 4] c: test: 2 other: true then yq m -a data1.yaml data3.yaml will output: a: simple b: [1, 2, 3, 4] c: test: 2 other: true d: hi Note that the 'b' array has concatenated the values from the second data file. Also note that other map keys are not overridden (field a). Multiple Documents \u00b6 Merge into single document \u00b6 Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d1 data1.yaml data3.yaml will output: something: else --- a: simple b: dog Merge into all documents \u00b6 Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d'*' data1.yaml data3.yaml will output: b: dog something: else --- a: simple b: dog","title":"Merge"},{"location":"merge/#merge-example","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m data1.yaml data2.yaml will output: a: simple b: [1, 2] c: test: 1","title":"Merge example"},{"location":"merge/#updating-files-in-place","text":"yq m -i data1.yaml data2.yaml will update the data1.yaml file with the merged result.","title":"Updating files in-place"},{"location":"merge/#overwrite-values","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -x data1.yaml data2.yaml will output: a: other b: [1, 2] c: test: 1","title":"Overwrite values"},{"location":"merge/#overwrite-values-with-arrays","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data3.yaml file of: b: [3, 4] c: test: 2 other: true d: false then yq m -x data1.yaml data3.yaml will output: a: simple b: [3, 4] c: test: 2 other: true d: false Notice that 'b' does not result in the merging of the values within an array.","title":"Overwrite values with arrays"},{"location":"merge/#append-values-with-arrays","text":"Given a data1.yaml file of: a: simple b: [1, 2] d: hi and data3.yaml file of: a: something b: [3, 4] c: test: 2 other: true then yq m -a data1.yaml data3.yaml will output: a: simple b: [1, 2, 3, 4] c: test: 2 other: true d: hi Note that the 'b' array has concatenated the values from the second data file. Also note that other map keys are not overridden (field a).","title":"Append values with arrays"},{"location":"merge/#multiple-documents","text":"","title":"Multiple Documents"},{"location":"merge/#merge-into-single-document","text":"Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d1 data1.yaml data3.yaml will output: something: else --- a: simple b: dog","title":"Merge into single document"},{"location":"merge/#merge-into-all-documents","text":"Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d'*' data1.yaml data3.yaml will output: b: dog something: else --- a: simple b: dog","title":"Merge into all documents"},{"location":"path_expressions/","text":"Path expressions are used to deeply navigate and match particular yaml nodes. As a general rule, you should wrap paths in quotes to prevent your CLI from processing '*, []' and other special characters. Simple expressions \u00b6 Maps \u00b6 a.b.c a: b: c: thing # MATCHES Arrays \u00b6 a.b[1].c a: b: - c: thing0 - c: thing1 # MATCHES - c: thing2 Appending to arrays \u00b6 (e.g. when using the write command) a.b[+].c a: b: - c: thing0 Will add a new entry: a: b: - c: thing0 - c: thing1 # NEW entry from [+] on B array. Splat \u00b6 Maps \u00b6 a.*.c a: b1: c: thing # MATCHES d: whatever b2: c: thing # MATCHES f: something irrelevant Prefix splat \u00b6 bob.item*.cats bob: item: cats: bananas # MATCHES something: cats: lemons itemThing: cats: more bananas # MATCHES item2: cats: apples # MATCHES thing: cats: oranges Arrays \u00b6 a.b[*].c a: b: - c: thing0 # MATCHES d: what..ever - c: thing1 # MATCHES d: blarh - c: thing2 # MATCHES f: thingamabob Deep Splat \u00b6 '**' will match arbitrary nodes for both maps and arrays: a.**.c a: b1: c: thing1 # MATCHES d: cat cat b2: c: thing2 # MATCHES d: dog dog b3: d: - f: c: thing3 # MATCHES d: beep - f: g: c: thing4 # MATCHES d: boop - d: mooo Search by children nodes \u00b6 a.(b.d==cat).b.c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy With prefixes \u00b6 a.(b.d==cat*).c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 # MATCHES d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy Special Characters \u00b6 Keys with dots \u00b6 When specifying a key that has a dot use key lookup indicator. b: foo.bar: 7 yaml r sample.yaml 'b[foo.bar]' yaml w sample.yaml 'b[foo.bar]' 9 Any valid yaml key can be specified as part of a key lookup. Note that the path is in quotes to avoid the square brackets being interpreted by your shell. Keys (and values) with leading dashes \u00b6 The flag terminator needs to be used to stop the app from attempting to parse the subsequent arguments as flags, if they start if a dash. yq n -j -- --key --value Will result in --key: --value","title":"Path Expressions"},{"location":"path_expressions/#simple-expressions","text":"","title":"Simple expressions"},{"location":"path_expressions/#maps","text":"a.b.c a: b: c: thing # MATCHES","title":"Maps"},{"location":"path_expressions/#arrays","text":"a.b[1].c a: b: - c: thing0 - c: thing1 # MATCHES - c: thing2","title":"Arrays"},{"location":"path_expressions/#appending-to-arrays","text":"(e.g. when using the write command) a.b[+].c a: b: - c: thing0 Will add a new entry: a: b: - c: thing0 - c: thing1 # NEW entry from [+] on B array.","title":"Appending to arrays"},{"location":"path_expressions/#splat","text":"","title":"Splat"},{"location":"path_expressions/#maps_1","text":"a.*.c a: b1: c: thing # MATCHES d: whatever b2: c: thing # MATCHES f: something irrelevant","title":"Maps"},{"location":"path_expressions/#prefix-splat","text":"bob.item*.cats bob: item: cats: bananas # MATCHES something: cats: lemons itemThing: cats: more bananas # MATCHES item2: cats: apples # MATCHES thing: cats: oranges","title":"Prefix splat"},{"location":"path_expressions/#arrays_1","text":"a.b[*].c a: b: - c: thing0 # MATCHES d: what..ever - c: thing1 # MATCHES d: blarh - c: thing2 # MATCHES f: thingamabob","title":"Arrays"},{"location":"path_expressions/#deep-splat","text":"'**' will match arbitrary nodes for both maps and arrays: a.**.c a: b1: c: thing1 # MATCHES d: cat cat b2: c: thing2 # MATCHES d: dog dog b3: d: - f: c: thing3 # MATCHES d: beep - f: g: c: thing4 # MATCHES d: boop - d: mooo","title":"Deep Splat"},{"location":"path_expressions/#search-by-children-nodes","text":"a.(b.d==cat).b.c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy","title":"Search by children nodes"},{"location":"path_expressions/#with-prefixes","text":"a.(b.d==cat*).c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 # MATCHES d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy","title":"With prefixes"},{"location":"path_expressions/#special-characters","text":"","title":"Special Characters"},{"location":"path_expressions/#keys-with-dots","text":"When specifying a key that has a dot use key lookup indicator. b: foo.bar: 7 yaml r sample.yaml 'b[foo.bar]' yaml w sample.yaml 'b[foo.bar]' 9 Any valid yaml key can be specified as part of a key lookup. Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Keys with dots"},{"location":"path_expressions/#keys-and-values-with-leading-dashes","text":"The flag terminator needs to be used to stop the app from attempting to parse the subsequent arguments as flags, if they start if a dash. yq n -j -- --key --value Will result in --key: --value","title":"Keys (and values) with leading dashes"},{"location":"prefix/","text":"yq p <yaml_file> <path> Prefixes a yaml document with the given path expression. The complete yaml content will be nested inside the new prefix path. See docs for path expression for more details. Prefix a document \u00b6 Given a data1.yaml file of: a: b: [1, 2] then yq p data1.yaml c.d will output: c: d: a: b: [1, 2] Updating files in-place \u00b6 yq p -i data1.yaml c will update the data1.yaml file so that the path 'c' prefixes the document. Multiple Documents \u00b6 Prefix a single document \u00b6 Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d1 data1.yaml c will output: something: else --- c: a: simple b: cat Prefix all documents \u00b6 Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d'*' data1.yaml c will output: c: something: else --- c: a: simple b: cat","title":"Prefix"},{"location":"prefix/#prefix-a-document","text":"Given a data1.yaml file of: a: b: [1, 2] then yq p data1.yaml c.d will output: c: d: a: b: [1, 2]","title":"Prefix a document"},{"location":"prefix/#updating-files-in-place","text":"yq p -i data1.yaml c will update the data1.yaml file so that the path 'c' prefixes the document.","title":"Updating files in-place"},{"location":"prefix/#multiple-documents","text":"","title":"Multiple Documents"},{"location":"prefix/#prefix-a-single-document","text":"Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d1 data1.yaml c will output: something: else --- c: a: simple b: cat","title":"Prefix a single document"},{"location":"prefix/#prefix-all-documents","text":"Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d'*' data1.yaml c will output: c: something: else --- c: a: simple b: cat","title":"Prefix all documents"},{"location":"read/","text":"yq r <yaml_file|json_file> <path_expression> TALK PRINTING ABOUT KEYS AND VALUES Returns the matching nodes of the path expression for the given yaml file (or STDIN). See docs for path expression for more details. Basic \u00b6 Given a sample.yaml file of: b: c: 2 then yq r sample.yaml b.c will output the value of '2'. From Stdin \u00b6 Given a sample.yaml file of: cat sample.yaml | yq r - b.c will output the value of '2'. Multiple Documents \u00b6 Reading from a single document \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq r -d1 sample.yaml b.c will output the value of '2'. Read from all documents \u00b6 Reading all documents will return the result as an array. This can be converted to json using the '-j' flag if desired. Given a sample.yaml file of: name: Fred age: 22 --- name: Stella age: 23 --- name: Android age: 232 then yq r -d'*' sample.yaml name will output: - Fred - Stella - Android","title":"Read"},{"location":"read/#basic","text":"Given a sample.yaml file of: b: c: 2 then yq r sample.yaml b.c will output the value of '2'.","title":"Basic"},{"location":"read/#from-stdin","text":"Given a sample.yaml file of: cat sample.yaml | yq r - b.c will output the value of '2'.","title":"From Stdin"},{"location":"read/#multiple-documents","text":"","title":"Multiple Documents"},{"location":"read/#reading-from-a-single-document","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq r -d1 sample.yaml b.c will output the value of '2'.","title":"Reading from a single document"},{"location":"read/#read-from-all-documents","text":"Reading all documents will return the result as an array. This can be converted to json using the '-j' flag if desired. Given a sample.yaml file of: name: Fred age: 22 --- name: Stella age: 23 --- name: Android age: 232 then yq r -d'*' sample.yaml name will output: - Fred - Stella - Android","title":"Read from all documents"},{"location":"value_parsing/","text":"This describes how values are parsed from the CLI to commands that create/update yaml (e.g. new/write). yq attempts to parse values intelligently, e.g. when a number is passed it - it will assume it's a number as opposed to a string. yq will not alter the representation of what you give. So if you pass '03.0' in, it will assume it's a number and keep the value formatted as it was passed in, that is '03.0'. The --tag flag can be used to override the tag type to force particular tags. Default behaviour \u00b6 Integers \u00b6 Given yq new key 3 results in key: 3 Given a formatted number yq new key 03 results in key: 03 yq keeps the number formatted as it was passed in. Float \u00b6 Given yq new key \"3.1\" results in key: 3.1 Note that quoting the number does not make a difference. Given a formatted decimal number yq new key 03.0 results in key: 03.0 yq will keep the number formatted as it was passed in Booleans \u00b6 yq new key true results in key: true Nulls \u00b6 yq new key null results in key: null yq new key '~' results in key: ~ yq new key '' results in key: Strings \u00b6 yq new key whatever results in key: whatever yq new key ' whatever ' results in key: ' whatever ' Using the tag field to override \u00b6 Previous versions of yq required double quoting to force values to be strings, this no longer works - instead use the --tag flag. Casting booleans \u00b6 yq new --tag '!!str' key true results in key: 'true' Casting nulls \u00b6 yq new --tag '!!str' key null results in key: 'null' Custom types \u00b6 yq new --tag '!!farah' key gold results in key: !!farah gold","title":"Value Parsing"},{"location":"value_parsing/#default-behaviour","text":"","title":"Default behaviour"},{"location":"value_parsing/#integers","text":"Given yq new key 3 results in key: 3 Given a formatted number yq new key 03 results in key: 03 yq keeps the number formatted as it was passed in.","title":"Integers"},{"location":"value_parsing/#float","text":"Given yq new key \"3.1\" results in key: 3.1 Note that quoting the number does not make a difference. Given a formatted decimal number yq new key 03.0 results in key: 03.0 yq will keep the number formatted as it was passed in","title":"Float"},{"location":"value_parsing/#booleans","text":"yq new key true results in key: true","title":"Booleans"},{"location":"value_parsing/#nulls","text":"yq new key null results in key: null yq new key '~' results in key: ~ yq new key '' results in key:","title":"Nulls"},{"location":"value_parsing/#strings","text":"yq new key whatever results in key: whatever yq new key ' whatever ' results in key: ' whatever '","title":"Strings"},{"location":"value_parsing/#using-the-tag-field-to-override","text":"Previous versions of yq required double quoting to force values to be strings, this no longer works - instead use the --tag flag.","title":"Using the tag field to override"},{"location":"value_parsing/#casting-booleans","text":"yq new --tag '!!str' key true results in key: 'true'","title":"Casting booleans"},{"location":"value_parsing/#casting-nulls","text":"yq new --tag '!!str' key null results in key: 'null'","title":"Casting nulls"},{"location":"value_parsing/#custom-types","text":"yq new --tag '!!farah' key gold results in key: !!farah gold","title":"Custom types"},{"location":"write/","text":"yq w <yaml_file> <path_expression> <new value> Updates all the matching nodes of path expression to the supplied value. See docs for path expression for more details. Basic \u00b6 Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.c cat will output: b: c: cat Updating files in-place \u00b6 yq w -i sample.yaml b.c cat will update the sample.yaml file so that the value of 'c' is cat. From STDIN \u00b6 cat sample.yaml | yq w - b.c blah Adding new fields \u00b6 Any missing fields in the path will be created on the fly. Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.d[+] \"new thing\" will output: b: c: cat d: - new thing Appending value to an array field \u00b6 Given a sample.yaml file of: b: c: 2 d: - new thing - foo thing then yq w sample.yaml \"b.d[+]\" \"bar thing\" will output: b: c: cat d: - new thing - foo thing - bar thing Note that the path is in quotes to avoid the square brackets being interpreted by your shell. Multiple Documents \u00b6 Update a single document \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d1 sample.yaml b.c 5 will output: something: else --- b: c: 5 Update all documents \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d'*' sample.yaml b.c 5 will output: something: else b: c: 5 --- b: c: 5 UPDATE THIS UPDATE THIS INCLUDE DELETE EXAMPLE Updating multiple values with a script \u00b6 Given a sample.yaml file of: b: c: 2 e: - name: Billy Bob and a script update_instructions.yaml of: b.c: 3 b.e[+].name: Howdy Partner then yq w -s update_instructions.yaml sample.yaml will output: b: c: 3 e: - name: Howdy Partner And, of course, you can pipe the instructions in using '-': cat update_instructions.yaml | yq w -s - sample.yaml","title":"Write/Update"},{"location":"write/#basic","text":"Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.c cat will output: b: c: cat","title":"Basic"},{"location":"write/#updating-files-in-place","text":"yq w -i sample.yaml b.c cat will update the sample.yaml file so that the value of 'c' is cat.","title":"Updating files in-place"},{"location":"write/#from-stdin","text":"cat sample.yaml | yq w - b.c blah","title":"From STDIN"},{"location":"write/#adding-new-fields","text":"Any missing fields in the path will be created on the fly. Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.d[+] \"new thing\" will output: b: c: cat d: - new thing","title":"Adding new fields"},{"location":"write/#appending-value-to-an-array-field","text":"Given a sample.yaml file of: b: c: 2 d: - new thing - foo thing then yq w sample.yaml \"b.d[+]\" \"bar thing\" will output: b: c: cat d: - new thing - foo thing - bar thing Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Appending value to an array field"},{"location":"write/#multiple-documents","text":"","title":"Multiple Documents"},{"location":"write/#update-a-single-document","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d1 sample.yaml b.c 5 will output: something: else --- b: c: 5","title":"Update a single document"},{"location":"write/#update-all-documents","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d'*' sample.yaml b.c 5 will output: something: else b: c: 5 --- b: c: 5 UPDATE THIS UPDATE THIS INCLUDE DELETE EXAMPLE","title":"Update all documents"},{"location":"write/#updating-multiple-values-with-a-script","text":"Given a sample.yaml file of: b: c: 2 e: - name: Billy Bob and a script update_instructions.yaml of: b.c: 3 b.e[+].name: Howdy Partner then yq w -s update_instructions.yaml sample.yaml will output: b: c: 3 e: - name: Howdy Partner And, of course, you can pipe the instructions in using '-': cat update_instructions.yaml | yq w -s - sample.yaml","title":"Updating multiple values with a script"}]}