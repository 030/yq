{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yq \u00b6 yq is a lightweight and portable command-line YAML processor The aim of the project is to be the jq or sed of yaml files. Install \u00b6 On MacOS: brew install yq On Ubuntu and other Linux distros supporting snap packages: snap install yq On Ubuntu 16.04 or higher from Debian package: sudo add-apt-repository ppa:rmescandon/yq sudo apt update sudo apt install yq -y or, Download latest binary or alternatively: GO111MODULE=on go get github.com/mikefarah/yq/v3 View on GitHub","title":"Install"},{"location":"#yq","text":"yq is a lightweight and portable command-line YAML processor The aim of the project is to be the jq or sed of yaml files.","title":"yq"},{"location":"#install","text":"On MacOS: brew install yq On Ubuntu and other Linux distros supporting snap packages: snap install yq On Ubuntu 16.04 or higher from Debian package: sudo add-apt-repository ppa:rmescandon/yq sudo apt update sudo apt install yq -y or, Download latest binary or alternatively: GO111MODULE=on go get github.com/mikefarah/yq/v3 View on GitHub","title":"Install"},{"location":"convert/","text":"Yaml to Json \u00b6 To convert output to json, use the --tojson (or -j) flag. This is supported by all commands. Each matching yaml node will be converted to json and printed out on a separate line. Given a sample.yaml file of: b: c: 2 then yq r -j sample.yaml will output {\"b\":{\"c\":2}} Given a sample.yaml file of: bob: c: 2 bab: c: 5 then yq r -j sample.yaml b* will output {\"c\":2} {\"c\":5} Json to Yaml \u00b6 To read in json, just pass in a json file instead of yaml, it will just work :) e.g given a json file {\"a\":\"Easy! as one two three\",\"b\":{\"c\":2,\"d\":[3,4]}} then yq r sample.json will output a: Easy! as one two three b: c: 2 d: - 3 - 4","title":"Convert"},{"location":"convert/#yaml-to-json","text":"To convert output to json, use the --tojson (or -j) flag. This is supported by all commands. Each matching yaml node will be converted to json and printed out on a separate line. Given a sample.yaml file of: b: c: 2 then yq r -j sample.yaml will output {\"b\":{\"c\":2}} Given a sample.yaml file of: bob: c: 2 bab: c: 5 then yq r -j sample.yaml b* will output {\"c\":2} {\"c\":5}","title":"Yaml to Json"},{"location":"convert/#json-to-yaml","text":"To read in json, just pass in a json file instead of yaml, it will just work :) e.g given a json file {\"a\":\"Easy! as one two three\",\"b\":{\"c\":2,\"d\":[3,4]}} then yq r sample.json will output a: Easy! as one two three b: c: 2 d: - 3 - 4","title":"Json to Yaml"},{"location":"create/","text":"yq n <path_expression> <new value> Yaml files can be created using the 'new' command. This works in the same way as the write command, but you don't pass in an existing Yaml file. Currently this does not support creating multiple documents in a single yaml file. See docs for path expression Creating a simple yaml file \u00b6 yq n b.c cat will output: b: c: cat Creating using a create script \u00b6 Create scripts follow the same format as the update scripts. Given a script create_instructions.yaml of: - command: update path: b.c value: #great things: frog # wow! then yq n -s create_instructions.yaml will output: b: c: #great things: frog # wow! You can also pipe the instructions in: cat create_instructions.yaml | yq n -s -","title":"Create"},{"location":"create/#creating-a-simple-yaml-file","text":"yq n b.c cat will output: b: c: cat","title":"Creating a simple yaml file"},{"location":"create/#creating-using-a-create-script","text":"Create scripts follow the same format as the update scripts. Given a script create_instructions.yaml of: - command: update path: b.c value: #great things: frog # wow! then yq n -s create_instructions.yaml will output: b: c: #great things: frog # wow! You can also pipe the instructions in: cat create_instructions.yaml | yq n -s -","title":"Creating using a create script"},{"location":"delete/","text":"yq delete <yaml_file|-> <path_expression> The delete command will delete all the matching nodes for the path expression in the given yaml input. See docs for path expression for more details. From STDIN \u00b6 Use \"-\" (without quotes) inplace of a file name if you wish to pipe in input from STDIN. cat sample.yaml | yq d - b.c Deleting nodes in-place \u00b6 Given a sample.yaml file of: b: c: 2 apples: green then yq d -i sample.yaml b.c will update the sample.yaml file so that the 'c' node is deleted Multiple Documents - delete from single document \u00b6 Given a sample.yaml file of: something: else field: leaveMe --- b: c: 2 field: deleteMe then yq w -d1 sample.yaml field will output: something: else field: leaveMe --- b: c: 2 Multiple Documents - delete from all documents \u00b6 Given a sample.yaml file of: something: else field: deleteMe --- b: c: 2 field: deleteMeToo then yq w -d'*' sample.yaml field will output: something: else --- b: c: 2 Note that '*' is in quotes to avoid being interpreted by your shell.","title":"Delete"},{"location":"delete/#from-stdin","text":"Use \"-\" (without quotes) inplace of a file name if you wish to pipe in input from STDIN. cat sample.yaml | yq d - b.c","title":"From STDIN"},{"location":"delete/#deleting-nodes-in-place","text":"Given a sample.yaml file of: b: c: 2 apples: green then yq d -i sample.yaml b.c will update the sample.yaml file so that the 'c' node is deleted","title":"Deleting nodes in-place"},{"location":"delete/#multiple-documents-delete-from-single-document","text":"Given a sample.yaml file of: something: else field: leaveMe --- b: c: 2 field: deleteMe then yq w -d1 sample.yaml field will output: something: else field: leaveMe --- b: c: 2","title":"Multiple Documents - delete from single document"},{"location":"delete/#multiple-documents-delete-from-all-documents","text":"Given a sample.yaml file of: something: else field: deleteMe --- b: c: 2 field: deleteMeToo then yq w -d'*' sample.yaml field will output: something: else --- b: c: 2 Note that '*' is in quotes to avoid being interpreted by your shell.","title":"Multiple Documents - delete from all documents"},{"location":"merge/","text":"Yaml files can be merged using the 'merge' command. Each additional file merged with the first file will set values for any key not existing already or where the key has no value. yq m <yaml_file> <path>... To Stdout \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m data1.yaml data2.yaml will output: a: simple b: [1, 2] c: test: 1 Updating files in-place \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -i data1.yaml data2.yaml will update the data1.yaml file so that the value of 'c' is 'test: 1'. Overwrite values \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -x data1.yaml data2.yaml will output: a: other b: [1, 2] c: test: 1 Overwrite values with arrays \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] and data3.yaml file of: b: [3, 4] c: test: 2 other: true d: false then yq m -x data1.yaml data3.yaml will output: a: simple b: [3, 4] c: test: 2 other: true d: false Notice that 'b' does not result in the merging of the values within an array. Append values with arrays \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] d: hi and data3.yaml file of: a: something b: [3, 4] c: test: 2 other: true then yq m -a data1.yaml data3.yaml will output: a: simple b: [1, 2, 3, 4] c: test: 2 other: true d: hi Note that the 'b' array has concatenated the values from the second data file. Also note that other map keys are not overridden (field a). Multiple Documents - merge into single document \u00b6 Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d1 data1.yaml data3.yaml will output: something: else --- a: simple b: dog Multiple Documents - merge into all documents \u00b6 Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d'*' data1.yaml data3.yaml will output: b: dog something: else --- a: simple b: dog","title":"Merge"},{"location":"merge/#to-stdout","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m data1.yaml data2.yaml will output: a: simple b: [1, 2] c: test: 1","title":"To Stdout"},{"location":"merge/#updating-files-in-place","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -i data1.yaml data2.yaml will update the data1.yaml file so that the value of 'c' is 'test: 1'.","title":"Updating files in-place"},{"location":"merge/#overwrite-values","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data2.yaml file of: a: other c: test: 1 then yq m -x data1.yaml data2.yaml will output: a: other b: [1, 2] c: test: 1","title":"Overwrite values"},{"location":"merge/#overwrite-values-with-arrays","text":"Given a data1.yaml file of: a: simple b: [1, 2] and data3.yaml file of: b: [3, 4] c: test: 2 other: true d: false then yq m -x data1.yaml data3.yaml will output: a: simple b: [3, 4] c: test: 2 other: true d: false Notice that 'b' does not result in the merging of the values within an array.","title":"Overwrite values with arrays"},{"location":"merge/#append-values-with-arrays","text":"Given a data1.yaml file of: a: simple b: [1, 2] d: hi and data3.yaml file of: a: something b: [3, 4] c: test: 2 other: true then yq m -a data1.yaml data3.yaml will output: a: simple b: [1, 2, 3, 4] c: test: 2 other: true d: hi Note that the 'b' array has concatenated the values from the second data file. Also note that other map keys are not overridden (field a).","title":"Append values with arrays"},{"location":"merge/#multiple-documents-merge-into-single-document","text":"Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d1 data1.yaml data3.yaml will output: something: else --- a: simple b: dog","title":"Multiple Documents - merge into single document"},{"location":"merge/#multiple-documents-merge-into-all-documents","text":"Currently yq only has multi-document support for the first document being merged into. The remaining yaml files will have their first document selected. Given a data1.yaml file of: something: else --- a: simple b: cat and data3.yaml file of: b: dog then yq m -x -d'*' data1.yaml data3.yaml will output: b: dog something: else --- a: simple b: dog","title":"Multiple Documents - merge into all documents"},{"location":"path_expressions/","text":"Path expressions are used to deeply navigate and match particular yaml nodes. As a general rule, you should wrap paths in quotes in the CLI to prevent your interpreter from processing '*, []' and other special characters. Simple expressions \u00b6 Maps \u00b6 a.b.c a: b: c: thing # MATCHES Arrays \u00b6 a.b[1].c a: b: - c: thing0 - c: thing1 # MATCHES - c: thing2 Appending to arrays \u00b6 (e.g. when using the write command) a.b[+].c a: b: - c: thing0 Will add a new entry: a: b: - c: thing0 - c: thing1 # NEW entry from [+] on B array. Splat \u00b6 Maps \u00b6 a.*.c a: b1: c: thing # MATCHES b2: c: thing # MATCHES Arrays \u00b6 a.b[*].c a: b: - c: thing0 # MATCHES - c: thing1 # MATCHES - c: thing2 # MATCHES Deep Splat \u00b6 '**' will match arbitrary nodes for both maps and arrays: a.**.c a: b1: c: thing1 # MATCHES b2: c: thing2 # MATCHES b3: d: - f: c: thing3 # MATCHES - f: g: c: thing4 # MATCHES Finding parents with particular children nodes \u00b6 a.(b.d==cat).b.c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy With prefixes \u00b6 a.(b.d==cat*).c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 # MATCHES d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy Special Characters \u00b6 Keys with dots \u00b6 When specifying a key that has a dot use key lookup indicator. b: foo.bar: 7 yaml r sample.yaml 'b[foo.bar]' yaml w sample.yaml 'b[foo.bar]' 9 Any valid yaml key can be specified as part of a key lookup. Note that the path is in quotes to avoid the square brackets being interpreted by your shell. Keys (and values) with leading dashes \u00b6 If a key or value has leading dashes, yq won't know that you are passing a value as opposed to a flag (and you will get a 'bad flag syntax' error). To fix that, you will need to tell it to stop processing flags by adding '--' after the last flag like so: yq n -t -- --key --value Will result in --key: --value","title":"Path Expressions"},{"location":"path_expressions/#simple-expressions","text":"","title":"Simple expressions"},{"location":"path_expressions/#maps","text":"a.b.c a: b: c: thing # MATCHES","title":"Maps"},{"location":"path_expressions/#arrays","text":"a.b[1].c a: b: - c: thing0 - c: thing1 # MATCHES - c: thing2","title":"Arrays"},{"location":"path_expressions/#appending-to-arrays","text":"(e.g. when using the write command) a.b[+].c a: b: - c: thing0 Will add a new entry: a: b: - c: thing0 - c: thing1 # NEW entry from [+] on B array.","title":"Appending to arrays"},{"location":"path_expressions/#splat","text":"","title":"Splat"},{"location":"path_expressions/#maps_1","text":"a.*.c a: b1: c: thing # MATCHES b2: c: thing # MATCHES","title":"Maps"},{"location":"path_expressions/#arrays_1","text":"a.b[*].c a: b: - c: thing0 # MATCHES - c: thing1 # MATCHES - c: thing2 # MATCHES","title":"Arrays"},{"location":"path_expressions/#deep-splat","text":"'**' will match arbitrary nodes for both maps and arrays: a.**.c a: b1: c: thing1 # MATCHES b2: c: thing2 # MATCHES b3: d: - f: c: thing3 # MATCHES - f: g: c: thing4 # MATCHES","title":"Deep Splat"},{"location":"path_expressions/#finding-parents-with-particular-children-nodes","text":"a.(b.d==cat).b.c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy","title":"Finding parents with particular children nodes"},{"location":"path_expressions/#with-prefixes","text":"a.(b.d==cat*).c a: - b: c: thing0 d: leopard ba: fast - b: c: thing1 # MATCHES d: cat ba: meowy - b: c: thing2 # MATCHES d: caterpillar ba: icky - b: c: thing3 # MATCHES d: cat ba: also meowy","title":"With prefixes"},{"location":"path_expressions/#special-characters","text":"","title":"Special Characters"},{"location":"path_expressions/#keys-with-dots","text":"When specifying a key that has a dot use key lookup indicator. b: foo.bar: 7 yaml r sample.yaml 'b[foo.bar]' yaml w sample.yaml 'b[foo.bar]' 9 Any valid yaml key can be specified as part of a key lookup. Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Keys with dots"},{"location":"path_expressions/#keys-and-values-with-leading-dashes","text":"If a key or value has leading dashes, yq won't know that you are passing a value as opposed to a flag (and you will get a 'bad flag syntax' error). To fix that, you will need to tell it to stop processing flags by adding '--' after the last flag like so: yq n -t -- --key --value Will result in --key: --value","title":"Keys (and values) with leading dashes"},{"location":"prefix/","text":"yq p <yaml_file> <path> Prefixes a yaml document with the given path expression. The complete yaml content will be nested inside the new prefix path. See docs for path expression for more details. To Stdout \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] then yq p data1.yaml c will output: c: a: simple b: [1, 2] Arbitrary depth \u00b6 Given a data1.yaml file of: a: b: [1, 2] then yq p data1.yaml c.d will output: c: d: a: b: [1, 2] Updating files in-place \u00b6 Given a data1.yaml file of: a: simple b: [1, 2] then yq p -i data1.yaml c will update the data1.yaml file so that the path 'c' is prefixed to all other paths. Multiple Documents - prefix a single document \u00b6 Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d1 data1.yaml c will output: something: else --- c: a: simple b: cat Multiple Documents - prefix all documents \u00b6 Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d'*' data1.yaml c will output: c: something: else --- c: a: simple b: cat","title":"Prefix"},{"location":"prefix/#to-stdout","text":"Given a data1.yaml file of: a: simple b: [1, 2] then yq p data1.yaml c will output: c: a: simple b: [1, 2]","title":"To Stdout"},{"location":"prefix/#arbitrary-depth","text":"Given a data1.yaml file of: a: b: [1, 2] then yq p data1.yaml c.d will output: c: d: a: b: [1, 2]","title":"Arbitrary depth"},{"location":"prefix/#updating-files-in-place","text":"Given a data1.yaml file of: a: simple b: [1, 2] then yq p -i data1.yaml c will update the data1.yaml file so that the path 'c' is prefixed to all other paths.","title":"Updating files in-place"},{"location":"prefix/#multiple-documents-prefix-a-single-document","text":"Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d1 data1.yaml c will output: something: else --- c: a: simple b: cat","title":"Multiple Documents - prefix a single document"},{"location":"prefix/#multiple-documents-prefix-all-documents","text":"Given a data1.yaml file of: something: else --- a: simple b: cat then yq p -d'*' data1.yaml c will output: c: something: else --- c: a: simple b: cat","title":"Multiple Documents - prefix all documents"},{"location":"read/","text":"yq r <yaml_file|json_file> <path_expression> Returns the matching nodes of the path expression for the given yaml file (or STDIN). See docs for path expression for more details. Basic \u00b6 Given a sample.yaml file of: b: c: 2 then yq r sample.yaml b.c will output the value of '2'. From Stdin \u00b6 Given a sample.yaml file of: cat sample.yaml | yq r - b.c will output the value of '2'. Splat \u00b6 Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq r sample.yaml bob.*.cats will output - bananas - apples - oranges Prefix Splat \u00b6 Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq r sample.yaml bob.item*.cats will output - bananas - apples Multiple Documents - specify a single document \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq r -d1 sample.yaml b.c will output the value of '2'. Multiple Documents - read all documents \u00b6 Reading all documents will return the result as an array. This can be converted to json using the '-j' flag if desired. Given a sample.yaml file of: name: Fred age: 22 --- name: Stella age: 23 --- name: Android age: 232 then yq r -d'*' sample.yaml name will output: - Fred - Stella - Android Arrays \u00b6 You can give an index to access a specific element: e.g.: given a sample file of b: e: - name: fred value: 3 - name: sam value: 4 then yq r sample.yaml 'b.e[1].name' will output 'sam' Note that the path is in quotes to avoid the square brackets being interpreted by your shell. Array Splat \u00b6 e.g.: given a sample file of b: e: - name: fred value: 3 - name: sam value: 4 then yq r sample.yaml 'b.e[*].name' will output: - fred - sam Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Read"},{"location":"read/#basic","text":"Given a sample.yaml file of: b: c: 2 then yq r sample.yaml b.c will output the value of '2'.","title":"Basic"},{"location":"read/#from-stdin","text":"Given a sample.yaml file of: cat sample.yaml | yq r - b.c will output the value of '2'.","title":"From Stdin"},{"location":"read/#splat","text":"Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq r sample.yaml bob.*.cats will output - bananas - apples - oranges","title":"Splat"},{"location":"read/#prefix-splat","text":"Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq r sample.yaml bob.item*.cats will output - bananas - apples","title":"Prefix Splat"},{"location":"read/#multiple-documents-specify-a-single-document","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq r -d1 sample.yaml b.c will output the value of '2'.","title":"Multiple Documents - specify a single document"},{"location":"read/#multiple-documents-read-all-documents","text":"Reading all documents will return the result as an array. This can be converted to json using the '-j' flag if desired. Given a sample.yaml file of: name: Fred age: 22 --- name: Stella age: 23 --- name: Android age: 232 then yq r -d'*' sample.yaml name will output: - Fred - Stella - Android","title":"Multiple Documents - read all documents"},{"location":"read/#arrays","text":"You can give an index to access a specific element: e.g.: given a sample file of b: e: - name: fred value: 3 - name: sam value: 4 then yq r sample.yaml 'b.e[1].name' will output 'sam' Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Arrays"},{"location":"read/#array-splat","text":"e.g.: given a sample file of b: e: - name: fred value: 3 - name: sam value: 4 then yq r sample.yaml 'b.e[*].name' will output: - fred - sam Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Array Splat"},{"location":"write/","text":"yq w <yaml_file> <path_expression> <new value> Updates all the matching nodes of path expression to the supplied value. See docs for path expression for more details. To Stdout \u00b6 Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.c cat will output: b: c: cat From STDIN \u00b6 cat sample.yaml | yq w - b.c blah Adding new fields \u00b6 Any missing fields in the path will be created on the fly. Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.d[+] \"new thing\" will output: b: c: cat d: - new thing Splat \u00b6 Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq w sample.yaml bob.*.cats meow will output: --- bob: item1: cats: meow item2: cats: meow thing: cats: meow Prefix Splat \u00b6 Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq w sample.yaml bob.item*.cats meow will output: --- bob: item1: cats: meow item2: cats: meow thing: cats: oranges Array Splat \u00b6 Given a sample.yaml file of: --- bob: - cats: bananas - cats: apples - cats: oranges then yq w sample.yaml bob[*].cats meow will output: --- bob: - cats: meow - cats: meow - cats: meow Appending value to an array field \u00b6 Given a sample.yaml file of: b: c: 2 d: - new thing - foo thing then yq w sample.yaml \"b.d[+]\" \"bar thing\" will output: b: c: cat d: - new thing - foo thing - bar thing Note that the path is in quotes to avoid the square brackets being interpreted by your shell. Multiple Documents - update a single document \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d1 sample.yaml b.c 5 will output: something: else --- b: c: 5 Multiple Documents - update all documents \u00b6 Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d'*' sample.yaml b.c 5 will output: something: else b: c: 5 --- b: c: 5 Note that '*' is in quotes to avoid being interpreted by your shell. Updating files in-place \u00b6 Given a sample.yaml file of: b: c: 2 then yq w -i sample.yaml b.c cat will update the sample.yaml file so that the value of 'c' is cat. Updating multiple values with a script \u00b6 Given a sample.yaml file of: b: c: 2 e: - name: Billy Bob and a script update_instructions.yaml of: b.c: 3 b.e[+].name: Howdy Partner then yq w -s update_instructions.yaml sample.yaml will output: b: c: 3 e: - name: Howdy Partner And, of course, you can pipe the instructions in using '-': cat update_instructions.yaml | yq w -s - sample.yaml Values starting with a hyphen (or dash) \u00b6 The flag terminator needs to be used to stop the app from attempting to parse the subsequent arguments as flags: yq w -- my.path -3 will output my: path: -3","title":"Write/Update"},{"location":"write/#to-stdout","text":"Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.c cat will output: b: c: cat","title":"To Stdout"},{"location":"write/#from-stdin","text":"cat sample.yaml | yq w - b.c blah","title":"From STDIN"},{"location":"write/#adding-new-fields","text":"Any missing fields in the path will be created on the fly. Given a sample.yaml file of: b: c: 2 then yq w sample.yaml b.d[+] \"new thing\" will output: b: c: cat d: - new thing","title":"Adding new fields"},{"location":"write/#splat","text":"Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq w sample.yaml bob.*.cats meow will output: --- bob: item1: cats: meow item2: cats: meow thing: cats: meow","title":"Splat"},{"location":"write/#prefix-splat","text":"Given a sample.yaml file of: --- bob: item1: cats: bananas item2: cats: apples thing: cats: oranges then yq w sample.yaml bob.item*.cats meow will output: --- bob: item1: cats: meow item2: cats: meow thing: cats: oranges","title":"Prefix Splat"},{"location":"write/#array-splat","text":"Given a sample.yaml file of: --- bob: - cats: bananas - cats: apples - cats: oranges then yq w sample.yaml bob[*].cats meow will output: --- bob: - cats: meow - cats: meow - cats: meow","title":"Array Splat"},{"location":"write/#appending-value-to-an-array-field","text":"Given a sample.yaml file of: b: c: 2 d: - new thing - foo thing then yq w sample.yaml \"b.d[+]\" \"bar thing\" will output: b: c: cat d: - new thing - foo thing - bar thing Note that the path is in quotes to avoid the square brackets being interpreted by your shell.","title":"Appending value to an array field"},{"location":"write/#multiple-documents-update-a-single-document","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d1 sample.yaml b.c 5 will output: something: else --- b: c: 5","title":"Multiple Documents - update a single document"},{"location":"write/#multiple-documents-update-all-documents","text":"Given a sample.yaml file of: something: else --- b: c: 2 then yq w -d'*' sample.yaml b.c 5 will output: something: else b: c: 5 --- b: c: 5 Note that '*' is in quotes to avoid being interpreted by your shell.","title":"Multiple Documents - update all documents"},{"location":"write/#updating-files-in-place","text":"Given a sample.yaml file of: b: c: 2 then yq w -i sample.yaml b.c cat will update the sample.yaml file so that the value of 'c' is cat.","title":"Updating files in-place"},{"location":"write/#updating-multiple-values-with-a-script","text":"Given a sample.yaml file of: b: c: 2 e: - name: Billy Bob and a script update_instructions.yaml of: b.c: 3 b.e[+].name: Howdy Partner then yq w -s update_instructions.yaml sample.yaml will output: b: c: 3 e: - name: Howdy Partner And, of course, you can pipe the instructions in using '-': cat update_instructions.yaml | yq w -s - sample.yaml","title":"Updating multiple values with a script"},{"location":"write/#values-starting-with-a-hyphen-or-dash","text":"The flag terminator needs to be used to stop the app from attempting to parse the subsequent arguments as flags: yq w -- my.path -3 will output my: path: -3","title":"Values starting with a hyphen (or dash)"}]}